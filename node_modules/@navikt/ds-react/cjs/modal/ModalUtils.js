"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useBodyScrollLock = exports.BODY_CLASS = exports.getCloseHandler = void 0;
const react_1 = __importDefault(require("react"));
function getCloseHandler(modalRef, header, onBeforeClose) {
    if (header && header.closeButton === false)
        return undefined;
    if (onBeforeClose) {
        return () => { var _a; return onBeforeClose() !== false && ((_a = modalRef.current) === null || _a === void 0 ? void 0 : _a.close()); };
    }
    return () => { var _a; return (_a = modalRef.current) === null || _a === void 0 ? void 0 : _a.close(); };
}
exports.getCloseHandler = getCloseHandler;
exports.BODY_CLASS = "navds-modal__document-body";
function useBodyScrollLock(modalRef, portalNode) {
    react_1.default.useEffect(() => {
        if (!modalRef.current || !portalNode)
            return; // We check both to avoid running this twice when not using portal
        if (modalRef.current.open)
            document.body.classList.add(exports.BODY_CLASS); // In case `open` is true initially
        const observer = new MutationObserver(() => {
            var _a;
            if ((_a = modalRef.current) === null || _a === void 0 ? void 0 : _a.open)
                document.body.classList.add(exports.BODY_CLASS);
            else
                document.body.classList.remove(exports.BODY_CLASS);
        });
        observer.observe(modalRef.current, {
            attributes: true,
            attributeFilter: ["open"],
        });
        return () => {
            observer.disconnect();
            document.body.classList.remove(exports.BODY_CLASS); // In case modal is unmounted before it's closed
        };
    }, [modalRef, portalNode]);
}
exports.useBodyScrollLock = useBodyScrollLock;

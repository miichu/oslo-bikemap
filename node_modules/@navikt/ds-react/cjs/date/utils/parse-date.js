"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseDate = exports.INPUT_DATE_STRING_FORMAT_MONTH = exports.INPUT_DATE_STRING_FORMAT_DATE = void 0;
const parse_1 = __importDefault(require("date-fns/parse"));
const isBefore_1 = __importDefault(require("date-fns/isBefore"));
const sub_1 = __importDefault(require("date-fns/sub"));
const _1 = require(".");
exports.INPUT_DATE_STRING_FORMAT_DATE = "dd.MM.yyyy";
exports.INPUT_DATE_STRING_FORMAT_MONTH = "MMMM yyyy";
const ALLOWED_INPUT_FORMATS_DATE = [
    exports.INPUT_DATE_STRING_FORMAT_DATE,
    "ddMMyyyy",
    "dd/MM/yyyy",
    "dd-MM-yyyy",
];
const ALLOWED_INPUT_FORMATS_MONTH = [
    "M/yyyy",
    "MM/yyyy",
    "M-yyyy",
    "MM-yyyy",
    "MM.yyyy",
    exports.INPUT_DATE_STRING_FORMAT_MONTH,
    ...ALLOWED_INPUT_FORMATS_DATE,
];
const parseDate = (date, today, locale, type, allowTwoDigitYear) => {
    let parsed;
    const ALLOWED_FORMATS = type === "date" ? ALLOWED_INPUT_FORMATS_DATE : ALLOWED_INPUT_FORMATS_MONTH;
    if (allowTwoDigitYear) {
        for (const format of ALLOWED_FORMATS) {
            parsed = (0, parse_1.default)(date, format, today, { locale });
            if ((0, _1.isValidDate)(parsed) &&
                !isTwoDigitYear(date, today, locale, ALLOWED_FORMATS)) {
                return parsed;
            }
        }
        for (const format of [
            ...ALLOWED_FORMATS.map((x) => x.replace("yyyy", "yy")),
        ]) {
            parsed = (0, parse_1.default)(date, format, today, { locale });
            if ((0, _1.isValidDate)(parsed) &&
                isTwoDigitYear(date, today, locale, ALLOWED_FORMATS)) {
                const convertedDate = assignCenturyToDate(date, format, today, locale);
                if ((0, _1.isValidDate)(new Date(convertedDate))) {
                    return new Date(convertedDate);
                }
                else {
                    return new Date("Invalid date");
                }
            }
        }
        return new Date("Invalid date");
    }
    else {
        for (const format of ALLOWED_FORMATS) {
            parsed = (0, parse_1.default)(date, format, today, { locale });
            if ((0, _1.isValidDate)(parsed) &&
                !isTwoDigitYear(date, today, locale, ALLOWED_FORMATS)) {
                return parsed;
            }
        }
        return new Date("Invalid date");
    }
};
exports.parseDate = parseDate;
function isTwoDigitYear(dateString, today, locale, formats) {
    let parsed;
    const newFormat = formats.map((x) => x.replace("yyyy", "yy"));
    for (const format of newFormat) {
        parsed = (0, parse_1.default)(dateString, format, today, { locale });
        if ((0, _1.isValidDate)(parsed)) {
            return true;
        }
    }
    return false;
}
function assignCenturyToDate(dateStr, format, today, locale) {
    const date20Century = (0, parse_1.default)(appendCenturyToTwoYearDigitDateString(dateStr, "19"), format.replace("yy", "yyyy"), today, { locale });
    const date21Century = (0, parse_1.default)(appendCenturyToTwoYearDigitDateString(dateStr, "20"), format.replace("yy", "yyyy"), today, { locale });
    if ((0, _1.isValidDate)(date20Century) && (0, _1.isValidDate)(date21Century)) {
        return (0, isBefore_1.default)(date20Century, (0, sub_1.default)(new Date(), {
            years: 80,
        }))
            ? date21Century
            : date20Century;
    }
    return new Date("Invalid date");
}
function appendCenturyToTwoYearDigitDateString(dateString, century) {
    const twoDigitYear = dateString.slice(-2);
    return `${dateString.slice(0, dateString.length - 2)}${century}${twoDigitYear}`;
}

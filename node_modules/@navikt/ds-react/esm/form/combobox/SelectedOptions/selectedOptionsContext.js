import React, { createContext, useCallback, useContext, useMemo, useState, } from "react";
import usePrevious from "../../../util/usePrevious";
import { useInputContext } from "../Input/inputContext";
import { useCustomOptionsContext } from "../customOptionsContext";
const SelectedOptionsContext = createContext({});
export const SelectedOptionsProvider = ({ children, value, }) => {
    const { clearInput, focusInput } = useInputContext();
    const { customOptions, removeCustomOption, addCustomOption, setCustomOptions, } = useCustomOptionsContext();
    const { allowNewValues, isMultiSelect, selectedOptions: externalSelectedOptions, onToggleSelected, options, } = value;
    const [internalSelectedOptions, setSelectedOptions] = useState([]);
    const selectedOptions = useMemo(() => externalSelectedOptions !== null && externalSelectedOptions !== void 0 ? externalSelectedOptions : [...customOptions, ...internalSelectedOptions], [customOptions, externalSelectedOptions, internalSelectedOptions]);
    const addSelectedOption = useCallback((option) => {
        var _a;
        const isCustomOption = !options
            .map((opt) => opt.toLowerCase())
            .includes((_a = option === null || option === void 0 ? void 0 : option.toLowerCase) === null || _a === void 0 ? void 0 : _a.call(option));
        if (isCustomOption) {
            allowNewValues && addCustomOption(option);
            !isMultiSelect && setSelectedOptions([]);
        }
        else if (isMultiSelect) {
            setSelectedOptions((prevSelectedOptions) => [
                ...prevSelectedOptions,
                option,
            ]);
        }
        else {
            setSelectedOptions([option]);
            setCustomOptions([]);
        }
        onToggleSelected === null || onToggleSelected === void 0 ? void 0 : onToggleSelected(option, true, isCustomOption);
    }, [
        addCustomOption,
        allowNewValues,
        isMultiSelect,
        onToggleSelected,
        options,
        setCustomOptions,
    ]);
    const removeSelectedOption = useCallback((option) => {
        const isCustomOption = customOptions.includes(option);
        if (isCustomOption) {
            removeCustomOption(option);
        }
        else {
            setSelectedOptions((prevSelectedOptions) => prevSelectedOptions.filter((selectedOption) => selectedOption !== option));
        }
        onToggleSelected === null || onToggleSelected === void 0 ? void 0 : onToggleSelected(option, false, isCustomOption);
    }, [customOptions, onToggleSelected, removeCustomOption]);
    const toggleOption = useCallback((option, event) => {
        if (selectedOptions.includes(option)) {
            removeSelectedOption(option);
        }
        else {
            addSelectedOption(option);
        }
        clearInput(event);
        focusInput();
    }, [
        addSelectedOption,
        clearInput,
        focusInput,
        removeSelectedOption,
        selectedOptions,
    ]);
    const prevSelectedOptions = usePrevious(selectedOptions);
    const selectedOptionsState = {
        addSelectedOption,
        isMultiSelect,
        removeSelectedOption,
        prevSelectedOptions,
        selectedOptions,
        setSelectedOptions,
        toggleOption,
    };
    return (React.createElement(SelectedOptionsContext.Provider, { value: selectedOptionsState }, children));
};
export const useSelectedOptionsContext = () => {
    const context = useContext(SelectedOptionsContext);
    if (!context) {
        throw new Error("useSelectedOptionsContext must be used within a SelectedOptionsProvider");
    }
    return context;
};
//# sourceMappingURL=selectedOptionsContext.js.map
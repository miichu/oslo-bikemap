import differenceInCalendarDays from "date-fns/differenceInCalendarDays";
import isWeekend from "date-fns/isWeekend";
import { useCallback, useRef, useState } from "react";
import { isMatch } from "react-day-picker";
import { formatDateForInput, getLocaleFromString, isValidDate, parseDate, } from "../utils";
import { useEscape } from "./useEscape";
import { useOutsideClickHandler } from "./useOutsideClickHandler";
const getValidationMessage = (val = {}) => (Object.assign({ isDisabled: false, isWeekend: false, isEmpty: false, isInvalid: false, isBefore: false, isAfter: false, isValidDate: true }, val));
/**
 *
 * @see 🏷️ {@link UseDatepickerOptions}
 * @see 🏷️ {@link UseDatepickerValue}
 * @see 🏷️ {@link DateValidationT}
 * @example
 * const { datepickerProps, inputProps } = useDatepicker({
 *   fromDate: new Date("Aug 23 2019"),
 *   toDate: new Date("Feb 23 2024"),
 *   onDateChange: console.log,
 *   onValidate: console.log,
 * });
 */
export const useDatepicker = (opt = {}) => {
    var _a, _b;
    const { locale: _locale = "nb", required, defaultSelected: _defaultSelected, today = new Date(), fromDate, toDate, disabled, disableWeekends, onDateChange, inputFormat, onValidate, defaultMonth, allowTwoDigitYear = true, openOnFocus = true, } = opt;
    const locale = getLocaleFromString(_locale);
    const inputRef = useRef(null);
    const [daypickerRef, setDaypickerRef] = useState();
    const [defaultSelected, setDefaultSelected] = useState(_defaultSelected);
    // Initialize states
    const [month, setMonth] = useState((_a = defaultSelected !== null && defaultSelected !== void 0 ? defaultSelected : defaultMonth) !== null && _a !== void 0 ? _a : today);
    const [selectedDay, setSelectedDay] = useState(defaultSelected);
    const [open, setOpen] = useState(false);
    const defaultInputValue = defaultSelected
        ? formatDateForInput(defaultSelected, locale, "date", inputFormat)
        : "";
    const [inputValue, setInputValue] = useState(defaultInputValue);
    const handleOpen = useCallback((open) => {
        var _a, _b;
        setOpen(open);
        open && setMonth((_b = (_a = selectedDay !== null && selectedDay !== void 0 ? selectedDay : defaultSelected) !== null && _a !== void 0 ? _a : defaultMonth) !== null && _b !== void 0 ? _b : today);
    }, [defaultMonth, defaultSelected, selectedDay, today]);
    useOutsideClickHandler(open, handleOpen, [
        daypickerRef,
        inputRef.current,
        (_b = inputRef.current) === null || _b === void 0 ? void 0 : _b.nextSibling,
    ]);
    useEscape(open, handleOpen, inputRef);
    const updateDate = (date) => {
        onDateChange === null || onDateChange === void 0 ? void 0 : onDateChange(date);
        setSelectedDay(date);
    };
    const updateValidation = (val = {}) => onValidate === null || onValidate === void 0 ? void 0 : onValidate(getValidationMessage(val));
    const reset = () => {
        var _a;
        updateDate(defaultSelected);
        setMonth((_a = defaultSelected !== null && defaultSelected !== void 0 ? defaultSelected : defaultMonth) !== null && _a !== void 0 ? _a : today);
        setInputValue(defaultInputValue !== null && defaultInputValue !== void 0 ? defaultInputValue : "");
        setDefaultSelected(_defaultSelected);
    };
    const setSelected = (date) => {
        var _a;
        updateDate(date);
        setMonth((_a = date !== null && date !== void 0 ? date : defaultMonth) !== null && _a !== void 0 ? _a : today);
        setInputValue(date ? formatDateForInput(date, locale, "date", inputFormat) : "");
    };
    const handleFocus = (e) => {
        if (e.target.readOnly) {
            return;
        }
        !open && openOnFocus && handleOpen(true);
        const day = parseDate(e.target.value, today, locale, "date", allowTwoDigitYear);
        if (isValidDate(day)) {
            setInputValue(formatDateForInput(day, locale, "date", inputFormat));
            const isBefore = fromDate && day && differenceInCalendarDays(fromDate, day) > 0;
            const isAfter = toDate && day && differenceInCalendarDays(day, toDate) > 0;
            !isBefore && !isAfter && setMonth(day);
        }
    };
    const handleBlur = (e) => {
        const day = parseDate(e.target.value, today, locale, "date", allowTwoDigitYear);
        isValidDate(day) &&
            setInputValue(formatDateForInput(day, locale, "date", inputFormat));
    };
    /* Only allow de-selecting if not required */
    const handleDayClick = (day, { selected }) => {
        if (day && !selected) {
            handleOpen(false);
            inputRef.current && inputRef.current.focus();
        }
        if (!required && selected) {
            updateDate(undefined);
            setInputValue("");
            updateValidation({ isValidDate: false, isEmpty: true });
            return;
        }
        updateDate(day);
        updateValidation();
        setMonth(day);
        setInputValue(day ? formatDateForInput(day, locale, "date", inputFormat) : "");
    };
    // When changing the input field, save its value in state and check if the
    // string is a valid date. If it is a valid day, set it as selected and update
    // the calendar’s month.
    const handleChange = (e) => {
        setInputValue(e.target.value);
        const day = parseDate(e.target.value, today, locale, "date", allowTwoDigitYear);
        const isBefore = fromDate && day && differenceInCalendarDays(fromDate, day) > 0;
        const isAfter = toDate && day && differenceInCalendarDays(day, toDate) > 0;
        if (!isValidDate(day) ||
            (disableWeekends && isWeekend(day)) ||
            (disabled && isMatch(day, disabled))) {
            updateDate(undefined);
            updateValidation({
                isInvalid: isValidDate(day),
                isWeekend: disableWeekends && isWeekend(day),
                isDisabled: disabled && isMatch(day, disabled),
                isValidDate: false,
                isEmpty: !e.target.value,
                isBefore: isBefore !== null && isBefore !== void 0 ? isBefore : false,
                isAfter: isAfter !== null && isAfter !== void 0 ? isAfter : false,
            });
            return;
        }
        if (isBefore || isAfter) {
            updateDate(undefined);
            updateValidation({
                isValidDate: false,
                isBefore: isBefore !== null && isBefore !== void 0 ? isBefore : false,
                isAfter: isAfter !== null && isAfter !== void 0 ? isAfter : false,
            });
            return;
        }
        updateDate(day);
        updateValidation();
        setMonth(defaultMonth !== null && defaultMonth !== void 0 ? defaultMonth : day);
    };
    const datepickerProps = {
        month,
        onMonthChange: (month) => setMonth(month),
        onDayClick: handleDayClick,
        selected: selectedDay !== null && selectedDay !== void 0 ? selectedDay : new Date("Invalid date"),
        locale: _locale,
        fromDate,
        toDate,
        today,
        open,
        onOpenToggle: () => handleOpen(!open),
        disabled,
        disableWeekends,
        bubbleEscape: true,
        ref: setDaypickerRef,
    };
    const inputProps = {
        onChange: handleChange,
        onFocus: handleFocus,
        onBlur: handleBlur,
        value: inputValue,
        ref: inputRef,
    };
    return { datepickerProps, inputProps, reset, selectedDay, setSelected };
};
//# sourceMappingURL=useDatepicker.js.map
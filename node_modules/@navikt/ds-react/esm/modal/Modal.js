var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React, { forwardRef, useContext, useEffect, useMemo, useRef, } from "react";
import { createPortal } from "react-dom";
import { useFloatingPortalNode } from "@floating-ui/react";
import cl from "clsx";
import dialogPolyfill, { needPolyfill } from "./dialog-polyfill";
import { Detail, Heading, mergeRefs, useId, useProvider } from "..";
import ModalBody from "./ModalBody";
import ModalHeader from "./ModalHeader";
import ModalFooter from "./ModalFooter";
import { getCloseHandler, useBodyScrollLock } from "./ModalUtils";
import { ModalContext } from "./ModalContext";
/**
 * A component that displays a modal dialog.
 *
 * @see [ðŸ“ Documentation](https://aksel.nav.no/komponenter/core/modal)
 * @see ðŸ·ï¸ {@link ModalProps}
 *
 * @example
 * State change with `useRef`
 * ```jsx
 * const ref = useRef<HTMLDialogElement>(null);
 * <Button onClick={() => ref.current?.showModal()}>Open modal</Button>
 * <Modal
 *   ref={ref}
 *   header={{
 *     label: "Optional label",
 *     icon: <FileIcon aria-hidden />,
 *     heading: "My heading",
 *   }}
 * >
 *   <Modal.Body>
 *     <BodyLong>Hello world</BodyLong>
 *   </Modal.Body>
 *   <Modal.Footer>
 *     <Button>Save</Button>
 *     <Button type="button" variant="tertiary" onClick={() => ref.current?.close()}>Close</Button>
 *   </Modal.Footer>
 * </Modal>
 * ```
 * @example
 * State change with `useState`
 * ```jsx
 * const [open, setOpen] = useState(false);
 * <Modal
 *   open={open}
 *   onClose={() => setOpen(false)}
 *   aria-labelledby="modal-heading"
 * >
 *   <Modal.Header>
 *     <Heading level="1" size="large" id="modal-heading">My heading</Heading>
 *   </Modal.Header>
 *   <Modal.Body>
 *     <BodyLong>Hello world</BodyLong>
 *   </Modal.Body>
 * </Modal>
 * ```
 */
export const Modal = forwardRef((_a, ref) => {
    var _b, _c;
    var { header, children, open, onBeforeClose, onCancel, width, portal, className, "aria-labelledby": ariaLabelledby, style } = _a, rest = __rest(_a, ["header", "children", "open", "onBeforeClose", "onCancel", "width", "portal", "className", "aria-labelledby", "style"]);
    const modalRef = useRef(null);
    const mergedRef = useMemo(() => mergeRefs([modalRef, ref]), [ref]);
    const ariaLabelId = useId();
    const rootElement = (_b = useProvider()) === null || _b === void 0 ? void 0 : _b.rootElement;
    const portalNode = useFloatingPortalNode({ root: rootElement });
    if (useContext(ModalContext)) {
        console.error("Modals should not be nested");
    }
    useEffect(() => {
        // If using portal, modalRef.current will not be set before portalNode is set.
        // If not using portal, modalRef.current is available first.
        // We check both to avoid activating polyfill twice when not using portal.
        if (needPolyfill && modalRef.current && portalNode) {
            dialogPolyfill.registerDialog(modalRef.current);
        }
    }, [modalRef, portalNode]);
    useEffect(() => {
        // We need to have this in a useEffect so that the content renders before the modal is displayed,
        // and in case `open` is true initially.
        // We need to check both modalRef.current and portalNode to make sure the polyfill has been activated.
        if (modalRef.current && portalNode && open !== undefined) {
            if (open && !modalRef.current.open) {
                modalRef.current.showModal();
            }
            else if (!open && modalRef.current.open) {
                modalRef.current.close();
            }
        }
    }, [modalRef, portalNode, open]);
    useBodyScrollLock(modalRef, portalNode);
    const isWidthPreset = typeof width === "string" && ["small", "medium"].includes(width);
    const component = (React.createElement("dialog", Object.assign({}, rest, { ref: mergedRef, className: cl("navds-modal", className, {
            "navds-modal--polyfilled": needPolyfill,
            "navds-modal--autowidth": !width,
            [`navds-modal--${width}`]: isWidthPreset,
        }), style: Object.assign(Object.assign({}, style), (!isWidthPreset ? { width } : {})), onCancel: (event) => {
            // FYI: onCancel fires when you press Esc
            if (onBeforeClose && onBeforeClose() === false) {
                event.preventDefault();
            }
            else if (onCancel)
                onCancel(event);
        }, "aria-labelledby": !ariaLabelledby && !rest["aria-label"] && header
            ? ariaLabelId
            : ariaLabelledby }),
        React.createElement(ModalContext.Provider, { value: {
                closeHandler: getCloseHandler(modalRef, header, onBeforeClose),
            } },
            header && (React.createElement(ModalHeader, null,
                header.label && (React.createElement(Detail, { className: "navds-modal__label" }, header.label)),
                React.createElement(Heading, { size: (_c = header.size) !== null && _c !== void 0 ? _c : "medium", level: "1", id: ariaLabelId },
                    React.createElement("span", { className: "navds-modal__header-icon" }, header.icon),
                    header.heading))),
            children)));
    if (portal) {
        if (portalNode)
            return createPortal(component, portalNode);
        return null;
    }
    return component;
});
Modal.Header = ModalHeader;
Modal.Body = ModalBody;
Modal.Footer = ModalFooter;
export default Modal;
//# sourceMappingURL=Modal.js.map